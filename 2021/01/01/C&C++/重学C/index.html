<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lemonforce.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第1章 概括C，C++发展历史C++编程语言的历史可追溯到1979，Bjarne Stroustrup；创立了带类的C。顾名思义，这是C语言的超集；1983，语言的名字真正变成了C++； C++在最开始可以称作C语言的增强版，但在后来，C++又引入了很多新的功能，逐步增强了C++的可用性1998年伴随着STL标准库的诞生，一堆新的功能和特性的产生，C++标准委员会发布了第一个国际标准C++ + I">
<meta property="og:type" content="article">
<meta property="og:title" content="重学C++">
<meta property="og:url" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/index.html">
<meta property="og:site_name" content="lemonforce">
<meta property="og:description" content="第1章 概括C，C++发展历史C++编程语言的历史可追溯到1979，Bjarne Stroustrup；创立了带类的C。顾名思义，这是C语言的超集；1983，语言的名字真正变成了C++； C++在最开始可以称作C语言的增强版，但在后来，C++又引入了很多新的功能，逐步增强了C++的可用性1998年伴随着STL标准库的诞生，一堆新的功能和特性的产生，C++标准委员会发布了第一个国际标准C++ + I">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201223102143368.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201223102347498.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201223102528975.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201223102825060.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201223103455728.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223200922486.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223202631579.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223203015112.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223203327586.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223203027946.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223203345009.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223203413257.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223203938786.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223204442744.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223205838649.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223210344827.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223210512868.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201223210650643.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201224134340183.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201225141211828.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201225143459977.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150149238.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150230551.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150313519.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150323797.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150333462.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150345396.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150356927.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150733299.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150755955.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225151214191.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225151228463.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225151247584.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225151300361.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201225151645163.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201225152018367.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201225155500804.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201225155622215.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201225155843132.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201225160011114.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201225160108807.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227130534981.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227130609551.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227130625119.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201227135040202.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227135227028.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227135108157.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201227135526147.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201227135731647.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201227144222284.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201227144236036.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201227144338165.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/重学C++.assets/image-20201227145058951.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227183910878.png">
<meta property="og:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227185649044.png">
<meta property="article:published_time" content="2021-01-01T09:01:42.000Z">
<meta property="article:modified_time" content="2021-01-02T12:03:44.957Z">
<meta property="article:author" content="lemonforce">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201223102143368.png">

<link rel="canonical" href="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>重学C++ | lemonforce</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">lemonforce</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lemonforce.github.io/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lemonforce">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemonforce">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          重学C++
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-01 17:01:42" itemprop="dateCreated datePublished" datetime="2021-01-01T17:01:42+08:00">2021-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-02 20:03:44" itemprop="dateModified" datetime="2021-01-02T20:03:44+08:00">2021-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
            </span>

          
            <span id="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/" class="post-meta-item leancloud_visitors" data-flag-title="重学C++" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第1章-概括"><a href="#第1章-概括" class="headerlink" title="第1章 概括"></a>第1章 概括</h1><h2 id="C，C-发展历史"><a href="#C，C-发展历史" class="headerlink" title="C，C++发展历史"></a>C，C++发展历史</h2><p>C++编程语言的历史可追溯到1979，Bjarne Stroustrup；创立了带类的C。顾名思义，这是C语言的超集；1983，语言的名字真正变成了C++；</p>
<p>C++在最开始可以称作C语言的增强版，但在后来，C++又引入了很多新的功能，逐步增强了C++的可用性1998年伴随着STL标准库的诞生，一堆新的功能和特性的产生，C++标准委员会发布了第一个国际标准C++ + ISO/IEC 1488：称为C++ 98；</p>
<p>在2011年中期，C++标准（称为C++ 11）完成了新的标准。<br>Boost库项目对新标准产生了相当大的影响，一些新模块直接从相应的Boost库中派生出来。</p>
<p>C++11-之后，C++以每三年一版的频度发布着新的语言标准，每一版都在基本保留向后兼容性的同时，提供着改进和新功能。</p>
<h2 id="为什么C-比C更好"><a href="#为什么C-比C更好" class="headerlink" title="为什么C++比C更好"></a>为什么C++比C更好</h2><p>当C++被作为C语言的超集诞生时，很多人会问：有什么是C++语言可以做到而C语言做不到的？</p>
<p>让我们先看一个简单的C++示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Trace</span><br><span class="line">Public：</span><br><span class="line">	<span class="keyword">void</span> print（<span class="keyword">char</span>* s） &#123;<span class="built_in">printf</span>（ <span class="string">&quot;%s&quot;</span> ， s）；&#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>随着时间的推移，我们需要增加一个新的功能点，比如通过一个状态信息来管理print这个函数的行为；</p>
<p>C的处理方式：添加全局变量和全局函数来处理</p>
<p>让我们看下C代码的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> noisy =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">void</span> trace2（<span class="keyword">char</span>*s）&#123;</span><br><span class="line">    <span class="keyword">if</span>（noisy）</span><br><span class="line">		<span class="built_in">printf</span>（<span class="string">&quot;%s\n&quot;</span>，s）；</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace_on</span><span class="params">()</span></span>&#123;</span><br><span class="line">    noisy =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace_off</span><span class="params">()</span></span>&#123;</span><br><span class="line">	noisy =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>C++如何来处理这样的扩展，使用面向对象的方式来封装：<br>让我们看代码的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class Trace &#123; #新功能：让它输出到标准输出之外的地方</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">Trace（） &#123; noisy = <span class="number">0</span>; f=<span class="built_in">stdout</span>;&#125;</span><br><span class="line">Trace（FILE* ff） &#123; noisy= <span class="number">0</span>; f=ff; &#125;</span><br><span class="line"><span class="keyword">void</span> print（<span class="keyword">char</span>* s）&#123;</span><br><span class="line">	<span class="keyword">if</span> （noisy）</span><br><span class="line">		<span class="built_in">fprintf</span>（f，<span class="string">&quot;%s\n&quot;</span>， s）;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> on（） &#123;noisy = <span class="number">1</span>；&#125;</span><br><span class="line"><span class="keyword">void</span> off（） &#123; noisy = <span class="number">0</span>； &#125;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">	<span class="keyword">int</span> noisy；</span><br><span class="line">	FILE* f；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>在C中进行功能扩展会比较困难</p>
<p>比如此例子里没有一个合适的位置来存储状态信息，一般而言，系统在不断增长过程中往往需要引入某些独一无二的东西，这样导致了在面对大型复杂系统是C的扩展非常的难以管理；</p>
<h2 id="C-的特点"><a href="#C-的特点" class="headerlink" title="C++的特点"></a>C++的特点</h2><p>优点：</p>
<ol>
<li>强大的抽象封装能力：这让C++语言具备了强大的开发工程能力，时在封装的同时C++最大程度的保留了高性能；</li>
<li>高性能：运行快，快并且占用资源少一直是C++语言的追求；</li>
<li>低功耗：特别适合在各种微型的嵌入式设备中运行高效的程序；</li>
</ol>
<p>缺点：</p>
<ol>
<li>语法相对复杂，细节比较多，学习曲线比较陡；</li>
<li>需要一些好的规范和范式，否则代码很难维护；</li>
</ol>
<p><strong><font size="5">C++主要用来做什么</font></strong></p>
<ol>
<li>大型桌面应用程序（如Google Chrome和Microsoft Office）</li>
<li>大型网站的后台，如Google的搜索引擎</li>
<li>游戏和游戏引擎（如Unity）</li>
<li>视觉库和A1引擎（如Opencv和Tensorflow）</li>
<li>数据库（Microsoft SQL Server和Mongodb）</li>
<li>其他（如自动驾驶系统，嵌入式设备等）</li>
</ol>
<p><strong><font size="5">总结</font></strong></p>
<p>总得来说，C++的开发成本比较高；对于内存和CPU要很高，低功耗并且程序被调用非常频繁等场景中，目前来说C++语言是最合适的语言</p>
<h1 id="第2章-基础语法"><a href="#第2章-基础语法" class="headerlink" title="第2章 基础语法"></a>第2章 基础语法</h1><p><strong><font size="5">编程语言的层次和类型</font></strong></p>
<ul>
<li>机器（Machine）语言，汇编语言等</li>
<li>编译型语言，如C++，C等；</li>
<li>解释型语言，如Basic，Python等；</li>
<li>脚本语言，如bash，csh等；</li>
</ul>
<p>从上到下，使用层次更接近于人类使用，但运行效率逐渐降低。</p>
<p>编译型语言一般需要经历编译和链接的过程，才能变成真正可执行的程序。</p>
<p><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201223102143368.png" alt="image-20201223102143368"></p>
<p>编译，链接的大致过程</p>
<p><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201223102347498.png" alt="image-20201223102347498"></p>
<p><strong><font size="5">数据类型的内部结构</font></strong></p>
<p>C++中的每个变量都有其数据类型，数据类型决定这变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。</p>
<p><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201223102528975.png" alt="image-20201223102528975"></p>
<p><code>bit</code>是位，<code>byte</code>是字节</p>
<p><code>1 byte = 8 bit</code></p>
<p><strong><font size="5">进制的表示</font></strong></p>
<p><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201223102825060.png" alt="image-20201223102825060"></p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201223103455728.png" alt="image-20201223103455728"></p>
<p>常见的数据类型的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> s = <span class="number">97</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">97</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> n = <span class="number">97</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">97.0f</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">97.0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> k = <span class="number">97.0</span>;</span><br><span class="line"><span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> w[<span class="number">10</span>] = <span class="string">L&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>内存未初始化为ccccccccccccc</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>C++中标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名字；</li>
<li>一个标识符以字母A-Z或a-z或下划线一开始，后跟零个或多个字母、下划线和数字（0-9） ；如buttonemail</li>
<li>一个标识符不允许使用数字开头，如1button；</li>
<li>一个标识符内不允许出现标点字符，比如@、&amp;和%；</li>
<li>不能将大小写混淆，C++是区分大小写的编程语言，比如，在C++中，HelloWorld和helloworld是两个不同的标识符；</li>
<li>不能使用C++关键字，原则上不允许长度超过32位；</li>
</ul>
<p>总结：标识符是开发者给自定义内容起的名字，一般只能使用字母，数字和下划线来定义，但是数字不能放首位。</p>
<p>一些建议：</p>
<ul>
<li>不要试图发明最好的命名规则，应该制定一个让大部分成员满意的命名规则，并且在项目组中贯彻执行；</li>
<li>标识符应该直观，可以望文知意，尽量使用英文单词组合的方式，不要使用汉语拼音；</li>
<li>标识符的长度应当符合<code>min-length&amp;&amp;max-information</code>，原则，不是长度越长就越好，如<code>maxVal</code>比<code>maxValueUnitOverflow</code>好；</li>
<li>变量的名字尽量使用<code>名词</code>或<code>形容词+名词</code>“，如<code>value</code>或<code>newValue</code></li>
<li>尽量避免名字中出现数字，如<code>value1</code> ， <code>value2</code>等，</li>
<li>函数名可以使用<code>动词+名词</code>，如<code>DrawGraph</code>；</li>
</ul>
<p>有些著名的命名规则可以参考，如微软的<code>匈牙利</code>命名法，如驼峰式<code>Camel</code>命名法或<code>Pascal</code>命名；</p>
<p>简单说明：<br>匈牙利命名法：开头字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，要求单词第一个字母大写，如<code>int iMyAge</code>；<br>Camel命名法：第一个单词首字母小写，后面其他单词首字母大写，如<code>int myAge</code><br>Pascal命名法：每个单词的第一个字母都大写，如<code>int MyAge</code>；</p>
<h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><p><strong><font size="5">变量</font></strong></p>
<p>变量：在程序运行过程中，其值可以改变的量为变量</p>
<p>变量在程序的执行中能够赋值，发生变化；</p>
<p>变量有一个名字，并在使用之前要说明其类型，一经说明，就在内存中占据与其类型相应的存储单元；</p>
<p><strong><font size="5">变量定义</font></strong></p>
<p>变量定义的基本形式是：</p>
<p>首先是类型说明随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。如：<code>int m=1，n = 1；</code></p>
<p>当变量在创建时获得了一个特定的值，我们说这个变量被初始化了。用于初始化变量的值可以是住意复杂的表达式。</p>
<p>当一次定义了一个或多个变量时，变量的名字随着定义就可以使用了。如：<code>int m = 1, n = 1</code> <code>int sum = m + n</code></p>
<p><strong><font size="5">常量</font></strong></p>
<p>常量：在程序运行过程中，其值一直保持不变的量为常量；</p>
<p>常量也区分不同的类型如：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>2，1024</td>
<td>整数型</td>
</tr>
<tr>
<td>2.0f，1024.0</td>
<td>实数型</td>
</tr>
<tr>
<td>‘h’</td>
<td>字符类型</td>
</tr>
<tr>
<td>‘hello world”</td>
<td>字符串类型</td>
</tr>
<tr>
<td>true，false</td>
<td>bool类型</td>
</tr>
</tbody></table>
<p>在编辑器中根据其表面形式即可判断其类型；</p>
<p><strong><font size="5">常量定义</font></strong></p>
<p>C++中有两种简单的定义常量的方法：</p>
<ol>
<li>使用<code>#define</code>，如：<code>#define PI 3.1415926;</code></li>
<li>使用<code>const</code>；如：<code>const double PI = 3.1415926；</code></li>
</ol>
<p>注明：尽量使用const定义变量，<code>#define</code>不会出现在编译器期，<br><code>define ASPECT RATIO 1.653 </code> //在编译时出错，很难排错<br><code>const double ASPECT RATIO = 1.653;</code>//在编译时出错，可以排错</p>
<p><strong><font size="5">整数常量</font></strong></p>
<p>整数常量可以是十进制、八进制或十六进制的常量。</p>
<p>前缀指定基数：<code>0x</code>或<code>0X</code>表示十六进制，<code>0</code>表示八进制，不带前缀则默认表示十进制。</p>
<p>整数常量也可以带一个后缀，后缀是<code>U</code>和<code>L</code>的组合，U表示无符号整数<code>unsigned</code>，L表示长整数<code>long</code>。</p>
<p>后缀可以是大写，也可以是小写，U和L的顺序任意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*整数常量*&#x2F;</span><br><span class="line">212		&#x2F;&#x2F;合法的</span><br><span class="line">215u 	&#x2F;&#x2F;合法的</span><br><span class="line">DxFeeL 	&#x2F;&#x2F;合法的</span><br><span class="line">078		&#x2F;&#x2F;非法的： 8不是八进制的数字</span><br><span class="line">032UU 	&#x2F;&#x2F;非法的：不能重复后缀</span><br></pre></td></tr></table></figure>
<p><strong><font size="5">布尔常量</font></strong></p>
<p>布尔常量共有两个，它们都是标准的C++关键字：<code>true</code>值代表真，<code>false</code>值代表假。</p>
<p><strong><font size="5">字符常量</font></strong></p>
<p>字符常量是括在单引号中。</p>
<p>如果常量以<code>L</code>（仅当大写时）开头，则表示它是一个宽字符常量（例如<code>L&#39;x&#39;</code>），此时它必须存储在<code>wchar_t</code>类型的变量中。否则，它就是一个窄字符常量（例如<code>&#39;x&#39;</code>），此时它可以存储在<code>char</code>类型的简单变量中；字符常量可以是一个普通的字符（例如<code>&#39;x&#39;</code>）、一个转义序列（例如<br><code>&#39;\t&#39;</code>），或一个通用的字符（例如<code>&#39;\u02C0&#39;</code>）；</p>
<p><strong><font size="5">转义字符</font></strong></p>
<table>
<thead>
<tr>
<th>\</th>
<th>\字符</th>
</tr>
</thead>
<tbody><tr>
<td>\‘</td>
<td>‘字符</td>
</tr>
<tr>
<td>\“</td>
<td>“字符</td>
</tr>
<tr>
<td>?</td>
<td>?字符</td>
</tr>
<tr>
<td>\a</td>
<td>警报铃声</td>
</tr>
<tr>
<td>\b</td>
<td>退格键</td>
</tr>
<tr>
<td>\f</td>
<td>换符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\ooo</td>
<td>—到三位的八进制数</td>
</tr>
<tr>
<td>\xhh</td>
<td>一个或多个数字的十六进制数</td>
</tr>
</tbody></table>
<h1 id="第3章-运算符与表达式"><a href="#第3章-运算符与表达式" class="headerlink" title="第3章 运算符与表达式"></a>第3章 运算符与表达式</h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。</p>
<p>C++内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<p><strong><font size="5">表达式</font></strong></p>
<p>在程序中，运算符是用来操作数据的，因此，这些数据也被称为操作数，使用运算符将操作数连接而成的式子称为：表达式。</p>
<p>表达式具有如下特点：</p>
<ul>
<li>常量和变量都是表达式，例如，常量<code>3.14</code>、变量<code>i</code>；</li>
<li>运算符的类型对应表达式的类型，例如，算术运算符对应算术表达式；</li>
<li>每一个表达式都有自己的值，即表达式都有运算结果；</li>
</ul>
<p><strong><font size="5">算术运算符</font></strong></p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加号</td>
<td align="left">返回两个操作数的加法。</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left">减号</td>
<td align="left">返回两个操作数的减法。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘法</td>
<td align="left">返回两个操作数的乘积(乘积)。</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">除法</td>
<td align="left">返回两个操作数的除法结果，即返回除法运算的商。</td>
</tr>
<tr>
<td align="left">％</td>
<td align="left">取模</td>
<td align="left">返回两个操作数上除法运算的其余部分。</td>
</tr>
<tr>
<td align="left">++</td>
<td align="left">自增</td>
<td align="left">返回这个操作数的+1</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left">自减</td>
<td align="left">返回这个操作数的-1</td>
</tr>
</tbody></table>
<p><strong><font size="5">关系运算符</font></strong></p>
<p>假设变量A的值为10，变量B的值为20，则：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td>（A== B） 为真。</td>
</tr>
<tr>
<td>!=</td>
<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td>（A= B）为真。</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td>（A&gt;B）不为真。</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td>（A&lt;B）为真。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td>（A&gt;=B）不为真。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td>（A&lt;= B）为真。</td>
</tr>
</tbody></table>
<p><strong><font size="5">逻辑运算符</font></strong></p>
<p>假设变量A的值为1，变量B的值为0，则：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>称为逻填与运算符。如果两个操作数都非零，则条件为真</td>
<td>(A&amp;&amp;B)为假</td>
</tr>
<tr>
<td>||</td>
<td>称为逻辑或运算符。如果两个操作教中有任意一个非零，则条件为真。</td>
<td>(A||B)为假</td>
</tr>
<tr>
<td>!</td>
<td>称为逻辑非运算符。用来逆转操作数的逻增状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td>!(A&amp;&amp;B)为假</td>
</tr>
</tbody></table>
<p><code>assert()</code>值为真，没问题；值为假，报错。</p>
<p><strong><font size="5">赋值运算符</font></strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>简单的喊值运算符，把右边操作数的值绘左边操作数</td>
<td>C = A + B 将把 A + B 的值給 C</td>
</tr>
<tr>
<td>+=</td>
<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td>C += A 相当于 C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>减目赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td>C -= A 相当于 C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td>C *= A 相当于 C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td>C /= A 相当于 C = C / A</td>
</tr>
<tr>
<td>%=</td>
<td>求模且赋值运算符，求两个操作数的模献值给左边操作数</td>
<td>C %= A 相当于 C = C % A</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移且赋值运算符</td>
<td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移且赋值运算符</td>
<td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与且值运算符</td>
<td>C &amp;= 2 等同于 C = C ^ 2</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或赋值运算符</td>
<td>C ^= 2 等同于 C = C ^ 2</td>
</tr>
<tr>
<td>|=</td>
<td>按位或且赋值运算符</td>
<td>C |= 2 等同于 C = C | 2</td>
</tr>
</tbody></table>
<p><strong><font size="5">位运算符</font></strong></p>
<p>位运算符作用于位，并逐位执行操作。&amp;、1和^的真值表如下所示：</p>
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>p &amp; q</th>
<th>p | q</th>
<th>p ^ q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong><font size="5">位逻辑运算符</font></strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>与 and</td>
</tr>
<tr>
<td>^</td>
<td>异或</td>
</tr>
<tr>
<td>|</td>
<td>或 or</td>
</tr>
<tr>
<td>~</td>
<td>取反</td>
</tr>
</tbody></table>
<p><strong><font size="5">移位运算符</font></strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;&lt;</td>
<td>左移</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
</tr>
</tbody></table>
<p><strong><font size="5">优先级</font></strong></p>
<p>位”与”、位”或”和位”异或”运算符都是双目运算符，其结合性都是从左向右的，优先级高于逻辑运算符，低于比较运算符，且从高到低依次为&amp;、^、|</p>
<p><strong><font size="5">位运算符示例</font></strong></p>
<p>假设变量A的值为10，变量B的值为20，则：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (A &amp; B) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 01010 &amp; 10100 = 00000 ==&gt; 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (A | B) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 01010 | 10100 = 11110 ==&gt;30</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (A ^ B) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 01010 ^ 10100 = 11110 ==&gt; 30</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (~A) &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//  0000000000001010 =</span></span><br><span class="line"><span class="comment">//11111111111110101 ==&gt; 0000000000001011 ==&gt; -11</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (A &lt;&lt; <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 00001010 &lt; 2 ==&gt; 00101000 ==&gt; 40</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (A &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 00001010 &gt;&gt; 2==&gt; 00000010 ==&gt; 2</span></span><br></pre></td></tr></table></figure>
<p><strong><font size="5">杂项运算符</font></strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>sizeof</td>
<td>sizeof运算符</td>
<td>返回变量的大小。例如，<code> sizeof(a)</code>将返回<code>4</code>，其中<code>a</code>是整数。</td>
</tr>
<tr>
<td>Condition？X:Y</td>
<td>条件运算符</td>
<td>如果<code>Condition</code>为真，则值为<code>X</code>，否则值为<code>Y</code>。</td>
</tr>
<tr>
<td>,</td>
<td>逗号运算符</td>
<td>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td>
</tr>
<tr>
<td>（点）和&gt;（头）</td>
<td>成员运算符</td>
<td>用于引用类、结构和共用体的成员。</td>
</tr>
<tr>
<td>Cast</td>
<td>强制转换运算符</td>
<td>把一种数据类型转换为另一种数据类型。例如 <code>int(2.2000)</code>将返回<code>2</code></td>
</tr>
<tr>
<td>&amp;</td>
<td>引用/取地址</td>
<td>返回变量的地址。例如<code>&amp;a</code>，将给出变量的实际地址。</td>
</tr>
<tr>
<td>*</td>
<td>解引用</td>
<td>指向一个变量。例如<code>*var</code>，将指向变量<code>var</code>。</td>
</tr>
</tbody></table>
<p>注意：Cast不建议使用</p>
<p><strong><font size="5">杂项运算符示例</font></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//4</span></span><br><span class="line"><span class="keyword">int</span> C = A &gt; B ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; C &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//0</span></span><br><span class="line"><span class="keyword">int</span> D = A &lt; B ? <span class="number">1</span> : <span class="number">0</span>;	</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; D &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> E= (A, B, C);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; E &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//0</span></span><br><span class="line"><span class="keyword">float</span> F = <span class="keyword">float</span>(E);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; F &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;F &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// OxFFXXX</span></span><br><span class="line"><span class="keyword">float</span> *P= &amp;F;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; P &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// OxFFXXX</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *P &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//0</span></span><br></pre></td></tr></table></figure>


<p><strong><font size="5">运算符优先级</font></strong></p>
<p>下表将按运算</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>相等</td>
<td><code>==</code>  <code>!=</code></td>
<td>从左到右</td>
</tr>
<tr>
<td>位与AND</td>
<td>&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>位异或XOR</td>
<td>^</td>
<td>从左到右</td>
</tr>
<tr>
<td>位或OR</td>
<td>|</td>
<td>从左到右</td>
</tr>
<tr>
<td>逻辑与AND</td>
<td>&amp;&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>逻辑或OR</td>
<td>||</td>
<td>从左到右</td>
</tr>
<tr>
<td>条件</td>
<td>?:</td>
<td>从右到左</td>
</tr>
<tr>
<td>赋值</td>
<td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code>  <code>%=</code> <code>&gt;&gt;=</code>  <code>&lt;&lt;=</code> <code>&amp;=</code> <code>^=</code> `</td>
<td>=`</td>
</tr>
<tr>
<td>逗号</td>
<td>,</td>
<td>从左到右</td>
</tr>
</tbody></table>
<p>符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>
<p>记住两点：</p>
<ol>
<li>一般来说，一元运算符优先级高于对应的二元运算符；</li>
<li>弄不清楚优先级，就加括号；</li>
</ol>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>程序的注释是解释性语句，您可以在C++代码中包含注释，这将提高源代码的可读性。</p>
<p>所有的编程语言都允许某种形式的注释。</p>
<p>C++支持单行注释和多行注释。</p>
<p>主释中的所有字符会被C++编器忽略。</p>
<p>单行注释：以<code>//</code>开始，直到行末为止</p>
<p>多行注释；C++注释以<code>/*</code>开始，以<code>*/</code>终止。</p>
<p><strong><font size="5">原则和建议</font></strong></p>
<ol>
<li>好的命名和代码本身就是最好的注释；如果代码本身很清楚，不需要额外加注释；</li>
<li>在重要代码段，或复杂代码处先写注释再写代码，这样思路更清晰，同时可以保证代码和注释的一致性；</li>
<li>注释不是越多越好，它是对代码的提示，如果要写就要清楚，并且保证和代码一致，如果更新了代码，请更新相应的注释；</li>
</ol>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>施工未完成···</p>
<p>机器数和真值</p>
<p>机器数：一个数在计算机中的二进制表示形式，叫做这个数的机器数。</p>
<p>机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1.</p>
<p>比如：</p>
<p>十进制数+3，就是<code>00000000000000000000000000000011</code></p>
<p>十进制数-3，就是<code>10000000000000000000000000000011</code></p>
<p>真值：真正的数学意义上的数值。</p>
<p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值；</p>
<p><strong><font size="5">为什么要用补码</font></strong></p>
<p>我们在设计软件系统时总是希望软件系统尽可能得简单通用于是人们希望</p>
<p>在只有加法运算器的情况下设计一种方法能计算减法？</p>
<h1 id="第4章-基础容器"><a href="#第4章-基础容器" class="headerlink" title="第4章 基础容器"></a>第4章 基础容器</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong><font size="5">概念</font></strong></p>
<ul>
<li>代表内存里一组连续的同类型存储区</li>
<li>可以用来把多个存储区合并成一个整体</li>
</ul>
<p>比如：<code>int arr[10] = &#123;1，2，3，4，5，6，7，8&#125;；</code></p>
<p><strong><font size="5">数组声明</font></strong></p>
<ul>
<li><code>int arr[10];</code></li>
<li>类型名称<code>int</code>表示数组里所有元素的类型</li>
<li>名称<code>arr</code>是数组的名称</li>
<li>整数<code>10</code>表示数组里包含的元素个数</li>
<li>数组里元素个数不可以改变</li>
</ul>
<p><strong><font size="5">使用</font></strong></p>
<ul>
<li>每个元素都有下标，通过下标可以直接访问任意一个元素；</li>
<li>下标从0开始到元素个数减一为止；</li>
<li>超过范围的下标不可以使用；</li>
<li>数组名称和下标一起可以表示数组里的元素 a[4]</li>
</ul>
<p><strong><font size="5">优点</font></strong></p>
<ul>
<li>可以编写循环依次处理数组里的所有元素</li>
<li>循环变量依次代表所有有效下标</li>
</ul>
<p><strong><font size="5">代码</font></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index= <span class="number">0</span>; index &lt; <span class="number">10</span>; ++index)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[index] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下标标识了一个数组元素在当前数组容器中的位置</p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223200922486.png" alt="image-20201223200922486" style="zoom:67%;">

<p><strong><font size="5">差一错误</font></strong></p>
<p><code>off-by-one error</code>（差一错误）</p>
<p>简单问题：100米，每10米需要一个栏杆，总共需要多少个栏杆？</p>
<p>答案：11个</p>
<p>假定整数满足边界条件<code>x &gt;= 16</code>并且<code>x&lt;=37</code>，那么此范围内<code>x</code>的可能取值个数有多少？</p>
<p>我们进行思考时有两个思考问题的原则：</p>
<ol>
<li>首先考虑最简单情况的特例，然后将结果外推；</li>
<li>仔细计算边界；</li>
</ol>
<p><code>x</code>的上界与下界重合时，即<code>x &gt;= 16 &amp;&amp; x &lt;= 16</code>，显然个数是<code>1</code>；假定下界位<code>low</code>，上界位<code>high</code>；当<code>low</code>与<code>high</code>重合时，<code>low=high</code>时，个数为<code>1</code>；据此外推，<code>high-low+1</code>个元素；所以答案是<code>37-16+1 = 22</code></p>
<p>这里最容易出错就是<code>high-low+1</code></p>
<p>用简单的编程技巧避免这种错误 –&gt; 使用数学上的左闭右开区间<code>[ , )</code>来表示范围</p>
<p>问题表示为：<code>x &gt;= 16</code>并且<code>x &lt;= 37 </code>–&gt;<code>x &gt;= 16 &amp;&amp; x &lt; 38</code>，这样<code>38-16=22</code></p>
<p>在C++中，我们一般使用下面的方式对数组进行遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; ++index) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[index] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt;= <span class="number">9</span>; ++index) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[index] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><font size="5">下标</font></strong></p>
<p>C语言中设计数组下标的原则：从0开始，使用非对称区间；</p>
<ol>
<li>让这个区间是一个非对称的区间[）；</li>
<li>让下界（左侧）可以取到值，让上界（右侧）取不到值；</li>
</ol>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223202631579.png" alt="image-20201223202631579" style="zoom:50%;">

<p><strong><font size="5">好处</font></strong></p>
<ol>
<li>取值范围的大小：上界-下界；</li>
<li>如果这个取值范围为空，上界值=下界值；</li>
<li>即使取值范围为空，上界值永远不可能小于下界值；</li>
</ol>
<p><strong><font size="5">增删改查</font></strong></p>
<p><font size="4">数组的增加</font></p>
<p><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223203015112.png" alt="image-20201223203015112" style="zoom:50%;"><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223203327586.png" alt="image-20201223203327586" style="zoom:50%;"></p>
<p><font size="4">数组的删除</font></p>
<p><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223203027946.png" alt="image-20201223203027946" style="zoom:50%;"><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223203345009.png" alt="image-20201223203345009" style="zoom:50%;"></p>
<p>在尾部添加删除，时间复杂度为<code>O(1)</code></p>
<p><font size="4">数组的访问</font></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223203413257.png" alt="image-20201223203413257" style="zoom:50%;">

<p>对数组<code>a</code>，</p>
<p>数组下标<code>index</code>方式访问：<code>a[2]=5</code>；</p>
<p>指针方式访问：<code>int *p =a</code> <code>*(p+2) =5</code>；</p>
<p>数组遍历高效，时间复杂度为<code>O(1)</code></p>
<p><font size="4">数组的查找</font></p>
<p>寻找第一个值为3的元素下标。</p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223203938786.png" alt="image-20201223203938786" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>（a[<span class="number">0</span>]）;	<span class="comment">//得到数组容量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; len; ++index)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[index]==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找时间复杂度一般为O（n），取决于数组容量。</p>
<p><strong><font size="5">二维数组</font></strong></p>
<p>包含行列两个维度的数组称为二维数组。</p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223204442744.png" alt="image-20201223204442744" style="zoom:67%;">

<p><font size="4">二维数组的访问</font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">4</span>]=&#123;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">2</span>; ++row)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">4</span>; ++col)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[row][col] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> tips：循环时尽可能要满足”空间局部性”: 在一个小的时间窗口内，访问的变量地址越接近越好，这样执行速度快；</p>
<p>一般来说，需要将最长的循环放在最内层，最短的循环放在最外层，以减少CPU跨切循环层的次数。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector是面向对象方式的动态数组</p>
<p>使用最简单的数组，无法实现动态扩容插入元素，因为容量有限。</p>
<p><font size="4">尾部添加操作</font></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223205838649.png" alt="image-20201223205838649" style="zoom:50%;">

<p>使用vector容器，轻松实现动态扩容插入元素，传统的C数组，容量有限，vector可以动态管理扩容；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;	<span class="comment">//使用vector之前的准备活动</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;; </span><br><span class="line">vec. push_back(<span class="number">5</span>);	<span class="comment">//在尾部进行元素插入操作</span></span><br></pre></td></tr></table></figure>
<p><font size="4">遍历操作</font></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223210344827.png" alt="image-20201223210344827" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; vec. size); + +index) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; vec[ index] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：可以使用<code>vector</code>的<code>capacity()</code>和<code>size()</code>方法来查看<code>vector</code>当前的容量和已经存储的元素个数。</p>
<p><font size="4">插入操作</font></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223210512868.png" alt="image-20201223210512868" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec. insert(--vec. end(), <span class="number">4</span>);	<span class="comment">//在中间进行元素插入操作</span></span><br></pre></td></tr></table></figure>
<p><font size="4">删除操作</font></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201223210650643.png" alt="image-20201223210650643" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec.pop_back();</span><br><span class="line">vec.erase(vec.end() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>注意：这里<code>vec.end()</code>的位置</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong><font size="5">字符串变量</font></strong></p>
<ul>
<li>字符串是以空字符<code>&#39;\0&#39;</code>结束的字符数组</li>
<li>空字符<code>&#39;\0&#39;</code>自动添加到字符串的内部表示中</li>
<li>在声明字符串变量时，应该位这个空结束符预留一个额外元素的空间如：<code>char strHelloWorld1[11] = &#123;&quot;helloworld&quot;&#125;;</code></li>
</ul>
<p><strong><font size="5">字符串常量</font></strong></p>
<ul>
<li><p>字符串常量是一对双引号括起来的字符序列</p>
</li>
<li><p>字符串中每个字符作为一个数组元素存储</p>
</li>
<li><p>例如字符串”helloworld”</p>
</li>
</ul>
<p><strong><font size="5">空字符</font></strong></p>
<p><code>0</code>, <code>&#39;\0&#39;</code> 与<code> &#39;0&#39;</code></p>
<p> 在计算机内部的机器码表示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="number">0</span>; --&gt; <span class="number">0x00</span></span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;\0&#x27;</span>; --&gt; <span class="number">0x00</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">&#x27;0&#x27;</span>;  --&gt; <span class="number">0x30</span></span><br></pre></td></tr></table></figure>
<p><strong><font size="5">ASCII码表</font></strong></p>
<p>ASCIl（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。</p>
<p>它是最通用的信息交换标准，并等同于国际标准ISO/IEC 646</p>
<p>ASCII码使用指定的7位或8位二进制数组合来表示128或256种可能的字符。</p>
<p>编码表可以参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ASCIl/309296?fr=aladdin%EF%BC%9B">https://baike.baidu.com/item/ASCIl/309296?fr=aladdin；</a></p>
<p>0x41（十进制65）对应A’；0x30（十进制48）对应字符’0’;</p>
<p>0x61（十进制97）对应’a’；0x7F（十进制127）对应字符DEL；</p>
<p><strong><font size="5">Unicode编码</font></strong></p>
<p>Unicode编码：最初的目的是把世界上的文字都映射到一套字符空间中</p>
<p>为了表示Unicode字符集，有3种（确切的说是5种）Unicode的编码方式：</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>说明</th>
<th>特点</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>UTF-8</td>
<td><code>1 byte</code>来表示1个字符，可以兼容ASCll码</td>
<td>存储效率高，变长（不方便内部随机访问）</td>
<td>无字节序问题，可作为外部编码</td>
</tr>
<tr>
<td>UTF-16</td>
<td><code>2 bytes</code>来表示1个字符</td>
<td>定长（方便内部随机访问）</td>
<td>有字节序问题，不能作外部编码</td>
</tr>
<tr>
<td>UTF-32</td>
<td><code>4 bytes</code>来表示1个字符</td>
<td>定长（方便内部随机访问）</td>
<td>有字节序问题，不能作外部编码</td>
</tr>
</tbody></table>
<p>UTF-16：分为UTF-16BE（big endian），UTF-16LE（little endian）</p>
<p>UTF-32：分为UTF-32BE（biq endian），UTF-32LE（little endian）</p>
<p>编码错误的根本原因在于编码方式和解码方式的不统一；</p>
<p>Windows的文件可能有BOM（byte order mark），如要在其他平台使用，可以去掉BOM。</p>
<p><strong><font size="5">表示方法</font></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* pStrHelloWrold = <span class="string">&quot;helloworld&quot;</span>;	<span class="comment">//指针表示方法</span></span><br><span class="line"><span class="keyword">char</span> strHelloWorld1 [<span class="number">11</span>] = &#123; <span class="string">&quot;helloworld&quot;</span>&#125;;	<span class="comment">//字符串数组表示法</span></span><br></pre></td></tr></table></figure>
<p><code>char[ ]</code>和<code>char*</code>的区别，把握两点:</p>
<ol>
<li>地址和地址存储的信息；</li>
<li>可变与不可变；</li>
</ol>
<p><code>strHelloWorld</code>不可变，<code>strHelloWorld[index]</code>的值可变；</p>
<p><code>pStrHelloWrold</code>可变，但是<code>pStrHelloWrold[index]</code>的值可变不可变取决于所指区间的存储区域是否可变。</p>
<p><strong><font size="5">常见操作</font></strong></p>
<p>字符串的长度：<code>strlen(s)</code>，返回字符串s的长度</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>e</td>
<td>l</td>
<td>l</td>
<td>o</td>
<td>w</td>
<td>o</td>
<td>r</td>
<td>l</td>
<td>d</td>
<td>\0</td>
</tr>
</tbody></table>
<p>注意：s的长度不包括<code>&#39;\0&#39;</code></p>
<p>字符串的比较：<code>strcmp(s1, s2)</code></p>
<ul>
<li>如果s1和s2是相同的，则返回0；</li>
<li>如果s1&lt;s2，则返回值小于0；</li>
<li>如果s1&gt;s2，则返回值大于0。</li>
</ul>
<p>两个字符串自左向右逐个字符相比（按ASCI1值大小相比较） ，直到出现不同的字符或遇<code>&#39;\0&#39;</code>，为止。</p>
<p>如：<code>&quot;A&quot; &lt; &quot;B&quot;</code> <code>&quot;A&quot; &lt; &quot;AB&quot;</code> <code>&quot;Apple&quot;&lt;&quot;Banana&quot;</code> <code>&quot;A&quot;&lt;&quot;a&quot;</code> <code>&quot;compare&quot;&lt;&quot;computer&quot;</code>；</p>
<p>字符串拷贝：<code>strcpy(s1, s2)</code></p>
<p>复制字符串s2到字符串s1</p>
<p>复制指定长度字符串：<code>strncpy(s1，s2，n)</code></p>
<p>将字符串s2中前n个字符拷贝到s1中</p>
<p>字符串拼接：<code>strcat(s1，s2)</code></p>
<p>将字符串s2接到s1后面</p>
<p>查找字符串：<code>strchr(s1，ch)</code></p>
<p>指向字符串s1中字符ch的第一次出现的位置</p>
<p>查找字符串：<code>strstr(s1，s2)</code></p>
<p>指向字符串s1中字符串s2的第一次出现的位置</p>
<p>字符串操作有风险，现在在VS中需要加上<code>_CRT_SECURE_NO_WARNINGS</code></p>
<p>使用<code>strnlen_s</code>，<code>strcpy_s</code>，<code>strncpy_s</code>，<code>strcat_s</code> 等API函数更安全！</p>
<p><strong><font size="5">操作问题</font></strong></p>
<p>C中原始字符串的操作在安全性和效率存在一定的问题</p>
<ol>
<li>缓冲区溢出问题</li>
<li><code>strlen</code>的效率可以提升：空间换时间</li>
</ol>
<p>补充</p>
<p>Rediss字符串的设计<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201224134340183.png" alt="image-20201224134340183" style="zoom:67%;">

<p>直接把长度保存在变量中，只需要取值即可，节省时间。</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>C++标准库中提供了string类型专门表示字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>使用string可以更为方便和安全的管理字符串</p>
<p>定义字符串变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s:<span class="comment">//定义空字符串</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;helloworld&quot;</span> ;<span class="comment">//定义并初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span> <span class="params">( <span class="string">&quot;helloworld&quot;</span> )</span></span>;</span><br><span class="line"><span class="built_in">string</span> s = <span class="built_in">string</span> ( <span class="string">&quot;helloworld&quot;</span> );</span><br></pre></td></tr></table></figure>
<p><strong><font size="5">相关函数</font></strong></p>
<p>获取字符串的长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.length() &lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//本质和上面一样</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>字符串比较： <code>==</code> <code>!=</code> <code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span> , s2 = <span class="string">&quot;world&quot;</span> ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (s1 == s2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (s1 != s2) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>转换为C风格的字符串：用于printf输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*c_str1 = s1.str();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The C-style string c_str1 is： &quot;</span> &lt;&lt; c_str1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>随机访问（获取字符串中某个字符） ： <code>[ ]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line">s[<span class="number">0</span>]= <span class="string">&quot;h&quot;</span> ;<span class="comment">//hello</span></span><br></pre></td></tr></table></figure>
<p>字符串拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line"><span class="built_in">string</span> s2 = s1;</span><br></pre></td></tr></table></figure>
<p>字符串连接： <code>+</code> <code>+=</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span> , s2 = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2; <span class="comment">//s3：helloworld</span></span><br><span class="line">s1 += s2;	<span class="comment">//s1：helloworld</span></span><br></pre></td></tr></table></figure>
<p>总结： </p>
<p>string结合了C++的新特性，使用起来比原始的C风格方法更安全和方便，对性能要求不是特别高的常见可以使用。</p>
<h1 id="第5章-指针，引用"><a href="#第5章-指针，引用" class="headerlink" title="第5章 指针，引用"></a>第5章 指针，引用</h1><p><strong><font size="5">计算机体系中的存储层次</font></strong></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201225141211828.png" alt="image-20201225141211828" style="zoom:80%;">

<p><strong><font size="5">内存单元内容与地址</font></strong></p>
<p>内存由很多内存单元组成。这些内存单元用于存放各种类型的数据。</p>
<p>计算机对内存的每个内存单元都进行了编号，这个编号就称为内存地址，地址决定了内存单元在内存中的位置。</p>
<p>记住这些内容单元地址不方便，于是C++语言的编译器让我们通过名字来访问这些内存位置。</p>
<h2 id="指针的定义和间接访问操作"><a href="#指针的定义和间接访问操作" class="headerlink" title="指针的定义和间接访问操作"></a>指针的定义和间接访问操作</h2><p>指针定义的基本形式：指针本身就是一个变量，其符合变量定义的基本形式，它存储的是值的地址。对类型<code>T</code>， <code>T*</code>是”到<code>T*</code>的指针”类<br>型，一个类型为<code>T*</code>的变量能保存一个类型<code>T</code>的对象的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">112</span>;</span><br><span class="line"><span class="keyword">float</span> c = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span>* d = &amp;a; </span><br><span class="line"><span class="keyword">float</span>* e = &amp;c;</span><br></pre></td></tr></table></figure>
<p>通过一个指针访问它所指向地址的过程称为间接访问（indirection）或者引用指针（dereferencing the point）；</p>
<p>这个用于执行间接访问的操作符是单目操作符<em>；</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (*d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (*e) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>关于变量，地址和指针变量小结：</p>
<ol>
<li><p>一个变量有三个重要的信息：</p>
<ol>
<li>变量的地址位置；</li>
<li>变量所存的信息；</li>
<li>变量的类型；</li>
</ol>
</li>
<li><p>指针变量是一个专门用来记录变量的地址的变量；</p>
</li>
</ol>
<p>通过指针变量可以间接的另一个变量的值；</p>
<h2 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h2><p>概念：</p>
<p>一般说法，编译器为其单独分配了一块存储空间，可以取其地址的，左值可以放在赋值运算符左边；</p>
<p>右值指的是数据本身；不能取到其自身地址，右值只能赋值运算右边；</p>
<p>具体分析：</p>
<p>左值最常见的情况如函数和数据成员的名字；</p>
<p>右值是没有标识符、不可以取地址的表达式，一般也称之为”临时对象”。</p>
<p>比如： <code>a = b + c;</code></p>
<p><code>&amp;a</code>是允许的操作，而<code>&amp;(b+c)</code>不能通过编译，</p>
<p>因此<code>a</code>是一个左值，而<code>(b+c)</code>是一个右值；</p>
<h2 id="原始指针"><a href="#原始指针" class="headerlink" title="原始指针"></a>原始指针</h2><p>一般类型指针T*</p>
<p>T是一个泛型，泛指任何一种类型；</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">4</span>; </span><br><span class="line"><span class="keyword">int</span>* iP= &amp;i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;(* iP) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span>* dP = &amp;d;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (* dP) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line"><span class="keyword">char</span>* cP = &amp;c; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (* cP) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>指针的数组（array of pointers）与数组的指针（a pointer to an array）：</p>
<p>指针的数组<code>T* t[ ]</code></p>
<p>数组的指针<code>T(*t) [ ]</code></p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>*a[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span>(*b)[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//注意：[ ]优先级比较高；</span></span><br></pre></td></tr></table></figure>
<p><strong><font size="5">const的修饰</font></strong></p>
<p><code>const pointer</code>与<code>pointer to const</code></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strHelloworld[]=<span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *pStr1 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> pStr2 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> pStr3 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">pStr1 = strHelloworld；</span><br><span class="line"><span class="comment">//pStr2 = strHelloworld；	// pStr2不可改</span></span><br><span class="line"><span class="comment">//pStr3 = strHelloworld；	// pStr3不可改</span></span><br></pre></td></tr></table></figure>
<p>关于const修饰的部分：</p>
<ol>
<li>看左侧最近的部分；</li>
<li>如果左侧没有，则看右侧；</li>
</ol>
<p><strong><font size="5">指向指针的指针</font></strong></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">int</span>* b = &amp;a</span><br><span class="line"><span class="keyword">int</span>** c = &amp;b;</span><br></pre></td></tr></table></figure>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201225143459977.png" alt="image-20201225143459977" style="zoom:67%;">

<p><code>*</code>操作符具有从右向左的结合性</p>
<p><code>**</code>这个表达式相当于<code>*(*c)</code>，必须从里向外逐层求值；</p>
<p><code>*c</code>得到的是<code>c</code>指向的位置，即<code>b</code>；</p>
<p><code>**c</code>相当于<code>*b</code>，得到变量<code>a</code>的值；</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>表达式的值</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>12</td>
</tr>
<tr>
<td>b</td>
<td>&amp;a</td>
</tr>
<tr>
<td>*b</td>
<td>a, 12</td>
</tr>
<tr>
<td>c</td>
<td>&amp;b</td>
</tr>
<tr>
<td>*c</td>
<td>b, &amp;a</td>
</tr>
<tr>
<td>**c</td>
<td>*b, a, 12</td>
</tr>
</tbody></table>
<p><strong><font size="5">未初始化和非法的指针</font></strong></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;		<span class="comment">//a这里指向哪里？这里会发生什么？</span></span><br><span class="line">*a = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>运气好的话：定位到一个非法地址，程序会出错，从而终止。</p>
<p>最坏的情况：定位到一个可以访问的地址，无意修改了它，这样的错误难以捕捉，引发的错误。<strong>可能与原先用于操作的代码完全不相干！</strong></p>
<p>用指针进行间接访问之前，一定要非常小心，<strong>确保它已经初始化，并被恰当的赋值</strong>。</p>
<p><strong><font size="5">NULL指针</font></strong></p>
<p>一个特殊的指针变量，表示不指向任何东西。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>NULL指针的概念非常有用：</p>
<p>它给了一种方法，来表示特定的指针目前未指向任何东西。</p>
<p>使用的注意事项：</p>
<p>对于一个指针，如果已经知道将被初始化为什么地址，那么请赋给它这个地址值，否则请把它设置为NULL。</p>
<p>在对一个指针进行间接引用前，请先判断这个指针的值为否为NULL；</p>
<p><strong><font size="5">杜绝野指针</font></strong></p>
<p>指向”垃圾”内存的指针。<code>if</code>等判断对它们不起作用，因为没有置<code>NULL</code>；</p>
<p>一般有三种情况：</p>
<ol>
<li>指针变量没有初始化</li>
<li>已经释放不用的指针没有置NULL，如delete和free之后的指针；</li>
<li>指针操作超越了变量的作用范围；</li>
</ol>
<p>指针使用的注意事项：</p>
<p>没有初始化的，不用的或者超出范围的指针请把值<strong>置为NULL</strong>。</p>
<p><strong><font size="5">基本运算</font></strong></p>
<p><code>&amp;</code> 与 <code>*</code>操作符；<code>++</code> 与 <code>--</code>操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span>* cp= &amp;ch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cp2 = ++cp;</span><br><span class="line"><span class="keyword">char</span>* cp3= cp++;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>表达式</th>
<th>右值</th>
<th>左值</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;ch</td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150149238.png" alt="image-20201225150149238" style="zoom:40%;"></td>
<td>非法</td>
</tr>
<tr>
<td>&amp;cp</td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150230551.png" alt="image-20201225150230551" style="zoom:40%;"></td>
<td>非法</td>
</tr>
<tr>
<td>*cp</td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150313519.png" alt="image-20201225150313519" style="zoom:50%;"></td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150323797.png" alt="image-20201225150323797" style="zoom:50%;"></td>
</tr>
<tr>
<td>*cp + 1</td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150333462.png" alt="image-20201225150333462" style="zoom:40%;"></td>
<td>非法</td>
</tr>
<tr>
<td>*(cp + 1)</td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150345396.png" alt="image-20201225150345396" style="zoom:40%;"></td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150356927.png" alt="image-20201225150356927" style="zoom:50%;"></td>
</tr>
<tr>
<td>++cp</td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150733299.png" alt="image-20201225150733299" style="zoom:40%;"></td>
<td>非法</td>
</tr>
<tr>
<td>cp++</td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225150755955.png" alt="image-20201225150755955" style="zoom:40%;"></td>
<td>非法</td>
</tr>
<tr>
<td>*++cp</td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225151214191.png" alt="image-20201225151214191" style="zoom:50%;"></td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225151228463.png" alt="image-20201225151228463" style="zoom:40%;"></td>
</tr>
<tr>
<td>*cp++</td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225151247584.png" alt="image-20201225151247584" style="zoom:40%;"></td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201225151300361.png" alt="image-20201225151300361" style="zoom:40%;"></td>
</tr>
</tbody></table>
<h2 id="存储区域"><a href="#存储区域" class="headerlink" title="存储区域"></a>存储区域</h2><p><strong><font size="5">栈和队列</font></strong></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201225151645163.png" alt="image-20201225151645163" style="zoom:80%;">

<p>每行代码在内存单元中的地址位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;	<span class="comment">//（GVAR）全局初始化区</span></span><br><span class="line"><span class="keyword">int</span>*p1;		<span class="comment">//（bss）全局未初始化区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	<span class="comment">//（text）代码区</span></span><br><span class="line">	<span class="keyword">int</span> b;	<span class="comment">//（stack）栈区变量</span></span><br><span class="line">    <span class="keyword">char</span> s[]=<span class="string">&quot;abc&quot;</span>;	<span class="comment">//（stack）栈区变量</span></span><br><span class="line">    <span class="keyword">int</span>*p2;			<span class="comment">//（stack）栈区变量</span></span><br><span class="line">    <span class="keyword">char</span>*p3 =<span class="string">&quot;123456&quot;</span>;	<span class="comment">//1234560在常量区，p3在（stack）栈区</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>;	<span class="comment">//（GVAR）全局（静态）初始化区</span></span><br><span class="line">    p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);	<span class="comment">//（heap）堆区变量</span></span><br><span class="line">    p2 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>);	<span class="comment">//（heap）堆区变量</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;			<span class="comment">//（text）代码区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201225152018367.png" alt="image-20201225152018367" style="zoom:80%;">

<p><strong><font size="5">堆heap</font></strong></p>
<p>动态分配资源–堆（heap）：</p>
<ol>
<li>从现代的编程语言角度来看，使用堆，或者说使用动态内存分配，是一件很自然不过的事情。</li>
<li>动态内存带来了不确定性：内存分配耗时需要多久？失败了怎么办？在实时性要求比较高的场合，如一些嵌入式控制器和电信设备。</li>
<li>一般而言，当我们在堆上分配内存时，很多语言会使用new这样的关键字，有些语言则是隐式分配。在C++中new的对应词是delete，因为C++是可以让程序员完全接管内存的分配释放的。</li>
</ol>
<p><strong><font size="5">分配和回收动态内存的原则</font></strong></p>
<p>程序通常需要牵涉到三个内存管理器的操作：</p>
<ol>
<li>分配一个某个大小的内存块；</li>
<li>释放一个之前分配的内存块；</li>
<li>垃圾收集操作，寻找不再使用的内存块并予以释放；</li>
</ol>
<p>这个回收策略需要实现性能、实时性、额外开销等各方面的平衡，很难有统一和高效的做法；</p>
<p>C++做了1，2两件事，而Java则做了1，3两件事。</p>
<h2 id="RAII初步"><a href="#RAII初步" class="headerlink" title="RAII初步"></a>RAII初步</h2><p>RAII（Resource Acquisition Is Initialization）：</p>
<p>C++所特有的资源管理方式。有少量其他语言，如D，Ada和Rust也采纳了RAll，但主流的编程语言中，C++是唯一一个依赖RAII来做资源管理的。</p>
<p>RAIl依托栈和析构函数，来对所有的资源——包括堆内存在内进行管理。对RAll的使用，使得C++不需要类似于Java那样的垃圾收集方法，也能有效地对内存进行管理。RAlI的存在，也是垃圾收集虽然理论上可以在C++使用，但从来没有真正流行过的主要原因。</p>
<p>RAII有些比较成熟的智能指针代表：如<code>std:：auto-ptr</code>和<code>boost：shared_ptr</code></p>
<p><strong><font size="5">栈和堆中的变量对比</font></strong></p>
<table>
<thead>
<tr>
<th></th>
<th>栈（stack）区</th>
<th>堆（heap）区</th>
</tr>
</thead>
<tbody><tr>
<td>作用域</td>
<td>函数体内，语句块{ }作用域</td>
<td>整个程序范围内，由new，malloc开始，delete，free结束</td>
</tr>
<tr>
<td>编译间大小确定</td>
<td>变量大小范围确定</td>
<td>变量大小范围不确定，需要运行期确定</td>
</tr>
<tr>
<td>大小范围</td>
<td>Windows系统默认栈大小是1M，linux常见默认的栈大小是8M或10M（通过ulimit-s查看；不同inux发行版的命令不保证相同）</td>
<td>所有系统的堆空间上限是接近内存（虚拟内存）的总大小的（一部分被OS占用）</td>
</tr>
<tr>
<td>内存分配方式</td>
<td>地址由高到低减少</td>
<td>地址由低到高增加</td>
</tr>
<tr>
<td>内容是否可变</td>
<td>可变</td>
<td>可变</td>
</tr>
</tbody></table>
<p><strong><font size="5">全局静态存储区和常量存储区的变量对比</font></strong></p>
<table>
<thead>
<tr>
<th></th>
<th>全局静态存储区</th>
<th>常量存储区</th>
</tr>
</thead>
<tbody><tr>
<td>存储内容</td>
<td>全局变量，静态变量</td>
<td>常量</td>
</tr>
<tr>
<td>编译期间大小是否确定</td>
<td>确定</td>
<td>确定</td>
</tr>
<tr>
<td>内容是否可变</td>
<td>可变</td>
<td>不可变</td>
</tr>
</tbody></table>
<p><strong><font size="5">内存泄漏</font></strong></p>
<p>什么是内存泄漏问题：</p>
<p>指程序中己动态分配的堆内存由于某种原因程序未释放或无法释，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<p>内存泄漏发生原因和排查方式：</p>
<ol>
<li>内存泄漏主要发生在堆内存分配方式中，即”配置了内存后，所有指向该内存的指针都遗失了”。若缺乏语言这样的垃圾回收机制，这样的内存片就无法归还系统。</li>
<li>因为内存泄漏属于程序运行中的问题，无法通过编译识别，所以只能在程序运行过程中来判别和诊断。</li>
</ol>
<h2 id="安全的指针"><a href="#安全的指针" class="headerlink" title="安全的指针"></a>安全的指针</h2><p>使用指针是非常危险的行为，可能存在空指针，野指针问题，并可能造成内存泄漏问题。可指针又非常的高效，所以我们希望以更安全的方式来使用指针。</p>
<p>一般有两种典型的方案：</p>
<ol>
<li>使用更安全的指针——智能指针；</li>
<li>不使用指针，使用更安全的方式——引用；</li>
</ol>
<p><strong><font size="5">智能指针</font></strong></p>
<p>C++中推出了四种常用的智能指针：<code>unique_ptr</code>，<code>shared_ptr</code>、<code>weak_ptr</code>和C++ 11中已经废弃（deprecated）的<code>auto-ptr</code>，在C++ 17中被正式删除；</p>
<p><strong><font size="5">auto-ptr</font></strong></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201225155500804.png" alt="image-20201225155500804" style="zoom: 50%;">

<p>由new expression获得对象，在auto_ptr对象销毁时，他所管理的对象也会自动被delete掉。</p>
<p>所有权转移：不小心把它传递给另外的智能指针，原来的指针就不再拥有这个对象了。</p>
<p>在拷贝/赋值过程中，会直接剥夺指针对原对象对内存的控制权，转交给新对象，然后再将原对象指针置为nullptr.</p>
<p><strong><font size="5">unique_ptr</font></strong></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201225155622215.png" alt="image-20201225155622215" style="zoom:50%;">

<p>unique_ptr是专属所有权，所以unique_ptr管理的内存，只能被一个对象持有，不支持复制和赋值。</p>
<p>移动语义：unique_ptr禁止了拷贝语义，但有时我们也需要能够转移所有权，于是提供了移动语义，即可以使用std::move（）进行控制所有权的转移。</p>
<p><strong><font size="5">shared_ptr</font></strong></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201225155843132.png" alt="image-20201225155843132" style="zoom:67%;">

<p>shared_ptr通过一个引用计数共享一个对象。</p>
<p>shared-ptr是为了解决auto-ptr在对象所有权上的局限性，在使用引用计数的机制上提供了可以共享所有权的智能指针，当然这需要额外的开销。</p>
<p>当引用计数为0时，该对象没有被使用，可以进行析构。</p>
<p><strong><font size="5">循环引用</font></strong></p>
<p>循环引用：引用计数会带来循环引用的问题</p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201225160011114.png" alt="image-20201225160011114" style="zoom: 67%;">

<p>循环引用会导致堆里的内存无法正常回收，造成内存泄漏。</p>
<p><strong><font size="5">weak_ptr</font></strong></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201225160108807.png" alt="image-20201225160108807" style="zoom:67%;">

<p>weak-ptr被设计为与sharedptr共同工作，用一种观察者模式工作。</p>
<p>作用是协助shared_ptr工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。</p>
<p>观察者意味着weak-ptr只对shared_ptr进行引用，而不改变其引用计数，当被观察的shared_ptr失效后，相应的weak_ptr也相应失效。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用是一种特殊的指针，不允许修改的指钮</p>
<p>使用指针有哪些坑：</p>
<ol>
<li>空指针；</li>
<li>野指针；</li>
<li>不知不觉改变了指针的值，却继续使用；</li>
</ol>
<p>使用引用，则可以：</p>
<ol>
<li>不存在空引用；</li>
<li>必须初始化；</li>
<li>一个引用永远指向它初始化的那个对象；</li>
</ol>
<p>引用的基本使用：可以认为是指定变量的别名，使用时可以认为时变量本身；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>, x2=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; rx =x;</span><br><span class="line">rx =<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;x &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">//2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; rx &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">//2</span></span><br><span class="line">rx =x2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;x &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">//3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; rx &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>有了指针为什么还需要引用？</p>
<p>Bjarne Stroustrup的解释：为了支持函数运算符重载；</p>
<p>有了引用为什么还需要指针？</p>
<p>Bjarne Stroustrup的解释：为7兼容C语言；</p>
<p><strong><font size="5">补充</font></strong></p>
<p>关于函数传递参数类型的说明：</p>
<ol>
<li>对内置基础类型（如int，double等）而言，在函数中传递时<code>pass by value</code>更高效；</li>
<li>对面向对象中自定义类型而言，在函数中传递时<code>pass by reference to const</code>更高效；</li>
</ol>
<h1 id="第6章-基础句法"><a href="#第6章-基础句法" class="headerlink" title="第6章 基础句法"></a>第6章 基础句法</h1><p><strong><font size="5">三种基本的程序结构</font></strong></p>
<table>
<thead>
<tr>
<th>顺序结构</th>
<th>分支结构</th>
<th>循环结构</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227130534981.png" alt="image-20201227130534981" style="zoom:50%;"></td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227130609551.png" alt="image-20201227130609551" style="zoom:50%;"></td>
<td><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227130625119.png" alt="image-20201227130625119" style="zoom:50%;"></td>
</tr>
</tbody></table>
<h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><p>单一语句：在任何一个表达式后面加上分号<code>;</code><br>如：<code>c= a+b;</code> <code>cout &lt;&lt;&quot;hello world&quot;&lt;&lt; endl;</code></p>
<p>复合语句：用一对花括号括起来的语句块，在语法上等效于一个单一的语句。</p>
<p><strong><font size="5">if分支语句</font></strong></p>
<p>if语句是最常用的一种分支语句，也称为条件语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：比较好的编程规范是<code>if</code>的花括号<code>&#123; &#125;</code>不允许不写，即使只是一个单一语句；</p>
<p><strong><font size="5">switch分支语句</font></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常数<span class="number">1</span>：</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常数<span class="number">2</span>：</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常数<span class="number">3</span>：</span><br><span class="line">        语句<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常数n：</span><br><span class="line">        语句n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span> ：</span><br><span class="line">        语句 n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code>分支与<code>if</code>分支比较</p>
<p>使用场景：</p>
<ol>
<li><code>switch</code>只支持常量值固定相等的分支判断；</li>
<li><code>if</code>还可以判断区间范围；</li>
<li>用<code>switch</code>能做的，用<code>if</code>都能做，但反过来则不行</li>
</ol>
<p>性能比较：</p>
<ol>
<li>分支少时，差别不是很大；分支多时，<code>switch</code>性能较高；</li>
<li><code>if</code>开始处几个分支效果高，之后效率递减；</li>
<li><code>switch</code>所有<code>case</code>的速度几乎一样；</li>
</ol>
<h2 id="自定义结构"><a href="#自定义结构" class="headerlink" title="自定义结构"></a>自定义结构</h2><p><strong><font size="5">枚举</font></strong></p>
<p>使用<code>#define</code>和<code>const</code>创建符号常量，使用<code>enum</code>不仅能够创建符号常量，还能定义新的数据类型；</p>
<p>枚举类型<code>enum(enumeration)</code>的声明和定义<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">wT</span>&#123;</span>Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday&#125;;</span><br><span class="line">    wT weekday;</span><br></pre></td></tr></table></figure>
<p>使用细节：</p>
<ol>
<li>枚举值不可以做左值；</li>
<li>非枚举变量不可以赋值给枚举变量；</li>
<li>枚举变量可以赋值给非枚举变量；</li>
</ol>
<p><strong><font size="5">结构体</font></strong></p>
<p>使用strcut定义的是结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">double</span> score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用union定义的是联合体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Score</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">	<span class="keyword">char</span> level;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="缺省对齐原则"><a href="#缺省对齐原则" class="headerlink" title="缺省对齐原则"></a>缺省对齐原则</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">short</span> y;</span><br><span class="line">&#125;;	<span class="comment">//sizeof（s1）→ 12</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">short</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;	<span class="comment">//sizeof（s2）→8</span></span><br></pre></td></tr></table></figure>
<p>32位CPU眼中的内存布局</p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201227135040202.png" alt="image-20201227135040202" style="zoom:67%;">

<p>s1</p>
<p><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227135227028.png" alt="image-20201227135227028"></p>
<p>s2</p>
<p><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227135108157.png" alt="image-20201227135108157"></p>
<p>32位CPU：<br>char：任何地址<br>short：偶数地址<br>int：4的整数倍地址<br>double：4的整数倍地址<br>修改默认编译选项：<br>Visual C++：</p>
<p><code>#pragma pack(n)</code></p>
<p>g++：</p>
<p><code>_attribute_(aligned(n))</code><br><code>_attribute_(_packed_)</code></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201227135526147.png" alt="image-20201227135526147" style="zoom:40%;">



<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>C++中提供了三种循环语句：<code>while</code>，<code>do while</code>和<code>for</code></p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201227135731647.png" alt="image-20201227135731647" style="zoom:50%;">



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>一个C++程序是由若干个源程序文件构成，而一个源程序是由若干个函数构成，函数将一段逻辑封装起来，便于复用；</p>
<p>从用户角度看，函数分成：</p>
<p>库函数：标准函数，由C++系统提供；</p>
<p>比如：strcpy_s等；</p>
<p>用户自定义函数：需要用户定义后使用；</p>
<p>比如：自定义的判断闰年函数isLeapYear；</p>
<p>函数的所有组成部分：</p>
<ol>
<li>返回类型：一个函数可以返回一个值</li>
<li>函数名称：这是函数的实际名称，函数名和参数列表一起构成了函数签名；</li>
<li>参数：参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数；</li>
</ol>
<p>函数重载overload与C++ Name Mangling：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> d)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong><font size="5">指向函数的指针与返回指针的函数</font></strong></p>
<p>每一个函数都占用一段内存单元，它们有一个起始地址，指向函数入口地址的指针称为函数指针。</p>
<p>一般形式：数据类型（指针变量名）（参数表）；</p>
<p>举例：int（<em>p）（int）；</em></p>
<p>注意与返回指针的函数之间区别：</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(*p)(<span class="keyword">int</span>);	<span class="comment">//是指针，指向一个函数入口地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>*<span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>;		<span class="comment">//是函数，返回的值是一个指针</span></span><br></pre></td></tr></table></figure>
<p>再如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ProcessNum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>(*p)(<span class="keyword">int</span> a, <span class="keyword">int</span> b))</span></span>;	<span class="comment">//int(*p)(int a, int b)是回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>*dest, <span class="keyword">const</span> <span class="keyword">char</span>*src)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>同一个班级，同一个公司，很容易出现同名的人；在C++程序种也会出现这样的问题。</p>
<p>命名空间这个概念，可作为附加信息来区分不同库中相同名称的函数、类、变量等，命名空间即定义了上下文。</p>
<p>本质上，命名空间就是定义了一个范围。</p>
<p>关键词：using和namespace的使用；</p>
<p><strong><font size="5">函数体</font></strong></p>
<p>函数的所有组成部分：</p>
<p>函数主体：函数主体包含一组定义函数执行任务的语句</p>
<p><strong><font size="5">内联函数</font></strong></p>
<p>如果一个函数是内联的（inline），那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。</p>
<p>引入内联函数的目的是为了解决程序中函数调用的效率问题：空间换时间</p>
<p>注意：内联函数内部不能有太复杂的逻辑，编译器有时会有自己的优化策略，所以内联不一定起作用；</p>
<h2 id="递归与数学归纳法"><a href="#递归与数学归纳法" class="headerlink" title="递归与数学归纳法"></a>递归与数学归纳法</h2><p>从数学归纳法说起</p>
<p>数学归纳法是证明当n等于任意一个自然数时某命题成立。</p>
<p>证明步骤分两步：</p>
<ol>
<li>证明当n=1时命题成立；</li>
<li>假设n=m时命题成立，那么可以推导出在n=m+1时命题也成立（m代表任意自然数）；</li>
</ol>
<p><strong><font size="5">递归</font></strong></p>
<p>递归（recursion）的四个基本法则：</p>
<ol>
<li>基准情形：无须递归就能解出；</li>
<li>不断推进：每一次递归调用都必须使求解状况朝接近基准情形的方向推进；</li>
<li>设计法则：假设所有的递归调用都能运行；</li>
<li>合成效益法则（compound interest rule）：求解一个问题的同一个实例时，切勿在不同的递归调用中做重复性的工作；</li>
</ol>
<p>由此可见，使用递归来计算诸如斐波那契数列数列并不是一个好主意；</p>
<p><strong><font size="5">递归的缺陷</font></strong></p>
<p>递归是一种重要的编程思想：</p>
<ol>
<li><p>很多重要的算法都包含递归的思想；</p>
</li>
<li><p>递归最大的缺陷：</p>
<ol>
<li>空间上需要开辟大量的栈空间；</li>
<li>时间上可能需要有大量重复运算；</li>
</ol>
</li>
</ol>
<p>递归的优化：</p>
<ol>
<li>尾递归：所有递归形式的调用都出现在函数的末尾；</li>
<li>使用循环替代；</li>
<li>使用动态规划，空间换时间；</li>
</ol>
<h1 id="第7章-高级句法"><a href="#第7章-高级句法" class="headerlink" title="第7章 高级句法"></a>第7章 高级句法</h1><p>抽象是一种认识事物本质的方法。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>C++使用struct，class来定义一个类：</p>
<p>struct的默认成员权限是public，</p>
<p>class的默认成员权限是private</p>
<p>除此之外，二者基本无差别；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span>	<span class="comment">//并不是真实世界中的学生，只是一个概念的抽象！</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">//成员变量</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">GetScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>面向对象的第一大误区</p>
<p>对象是对现实世界中具体物体的反映，继承是对物体分类的反映？</p>
<p>不是。</p>
<p>抽象一具体类型</p>
<p>让自定义的类像内置类型一样；</p>
<p>一个<code>int</code>型的变量，可以完成<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，比较，输出，<code>++</code>等一系列操作；</p>
<p>如果现在有一个自定义的复数类型，那么它的操作应该什么样？我们希望可以像使用int一样自然的使用它，同时它对我们是一个黑盒，一种抽象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i);</span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>--(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex <span class="keyword">operator</span>/(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt; (<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h2><p>传统的C中/0有print，scanf，getch，gets等函数，它们的问题是：</p>
<ol>
<li>不可编程，仅仅能识别固有的数据类型；</li>
<li>代码的可移植性差，有很多的坑；</li>
</ol>
<p>C++中的I/O流istream，ostream等：</p>
<ol>
<li>可编程，对于类库的而设计者来说很有用</li>
<li>简化编程，能使得/0的风格一致；</li>
</ol>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201227144222284.png" alt="image-20201227144222284" style="zoom:67%;">

<p>I/O流类层次结构图</p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201227144236036.png" alt="image-20201227144236036" style="zoom:80%;">

<p>IO缓存区</p>
<p>标准0提供的三种类型的缓存模式：</p>
<ol>
<li>按块存：如文件系统；</li>
<li>按行缓存：\n；</li>
<li>不缓存；</li>
</ol>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201227144338165.png" alt="image-20201227144338165" style="zoom:50%;">

<p>文件操作</p>
<p>输入流的起点和输出流的终点都可以是磁盘文件；</p>
<p>文件： C++把每个文件都看成是一个有序的字节序列，每个文件都以文件结束标志结束。</p>
<p>按照文件中数据的组织形式可把文件分成为：</p>
<ol>
<li>文本文件：文件中信息形式为ASCI1码文件，每个字符占一个字节；</li>
<li>二进制文件：文件中信息的形式与其在内存中的形式相同；</li>
</ol>
<p>文件操作步骤，对于文件操作要做以下事情：</p>
<ol>
<li>打开文件用于读和写open；</li>
<li>检查打开是否成功fail；</li>
<li>读或者写read，write；</li>
<li>检查是否读完EOF（end of file）；</li>
<li>使用完文件后关闭文件close；</li>
</ol>
<p>文件的打开方式</p>
<table>
<thead>
<tr>
<th>命令行</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>ios::in</code></td>
<td>打开文件进行读操作（ifstream默认模式）；</td>
</tr>
<tr>
<td>ios::out</td>
<td>打开文件进行写操作（ofstream默认模式）；</td>
</tr>
<tr>
<td>ios::ate</td>
<td>打开一个已有输入或输出文件并查找到文件尾；</td>
</tr>
<tr>
<td>ios::app</td>
<td>打开文件以便在文件的尾部添加数据；</td>
</tr>
<tr>
<td>ios::nocreate</td>
<td>如果文件不存在，则打开操作失败；</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如文件存在，清除文件原有内容（默认）；</td>
</tr>
<tr>
<td>ios::binary</td>
<td>以二进制方式打开；</td>
</tr>
</tbody></table>
<p>头文件的重复包含问题<br>为了避免同一个文件被include多次，有两种方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SOMEFILE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SOMEFILE_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>使用宏来防止同一个文件被多次包含；</p>
<p>优点：可移植性好；</p>
<p>缺点：无法防止宏名重复，难以排错；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br></pre></td></tr></table></figure>
<p>使用编译器来防止同一个文件被多次包含；</p>
<p>优点：可以防止宏名重复，易排错；</p>
<p>缺点：可移植性不好；</p>
<p>深拷贝与浅拷贝，写时复制</p>
<p>浅拷贝：只拷贝指针地址，C++默认拷贝构造函数与赋值运算符重载都是浅拷贝；</p>
<p>节省空间，但容易引发多次释放；</p>
<p>深拷贝：重新分配堆内存，拷贝指针指向内容。</p>
<p>浪费空间，但不会导致次放；</p>
<img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/../../重学C++.assets/image-20201227145058951.png" alt="image-20201227145058951" style="zoom:80%;">

<p>怎么兼有二者的优点？</p>
<p>方案一：引用计数；</p>
<p>方案二：C++新标准的移动语义；</p>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><p>封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问，封装可以使得代码模块化；</p>
<p>继承性：让某种类型对象获得另一个类型对象的属性和方法，继承可以扩展已存在的代码；</p>
<p>多态性：同一事物表现出不同事物的能力，即向不同对象会产生不同的行为，多态的目的则是为了接口重用；</p>
<p>面向对象到底是什么</p>
<p>面向对象是软件工程发展到一定阶段为了管理代码和数据提出的一种忘法，它没有解决以前解决不了的问题，不是万能的</p>
<p>面向对象不是对现实世界的映射；但</p>
<ul>
<li>它的封装性可以把问题简化，便于抽象；</li>
<li>它的继承可以减少代码重复，避免重新发明轮子；</li>
<li>它的多态可以实现灵活的功能扩充，提升开发效率；</li>
</ul>
<p>面向对象为我们便捷的开发出能适应变化的软件提供了可能，但还不够：</p>
<h1 id="第8章-编程思想"><a href="#第8章-编程思想" class="headerlink" title="第8章 编程思想"></a>第8章 编程思想</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>·一个模式描述了一个不断发生的问题及这个问题的解决方案模式是前人的设计经验上总结出来的对于一些普遍存在的问题提供的通用的解决方案；比如单例模式，观察者模式等；</p>
<p>软件中有很多模式：</p>
<ul>
<li>面向对象的常见23种设计模式；</li>
<li>反模式；</li>
<li>企业应用架构模式等；</li>
</ul>
<p><strong><font size="5">23种常见面向对象可复用的设计模式</font></strong></p>
<p><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227183910878.png" alt="image-20201227183910878"></p>
<p><strong><font size="5">单例（Singleton）模式</font></strong></p>
<p>有些时候，我们需要整个程序中有且只有一个实例</p>
<p>常见场景：如系统日志， Windows资源管理器窗口，数据库分配主键操作等</p>
<p>实现思路：</p>
<ol>
<li>Singleton拥有一个私有构造函数，确保用户无法通过new直接实例它；</li>
<li>包含一个静态私有成员变量instance与静态公有方法Instance（）；</li>
</ol>
<p><strong><font size="5">观察者（Observer）模式</font></strong></p>
<p>在观察者模式中，观察者需要直接订阅目标事件；在目标发出内容改变的事件后，直接接收事件并作出响应，对象常是一对多关系；</p>
<p>常见场景：各种MVC的框架中， Model的变化通知，各种类型的View时几乎都存在这种模式；</p>
<p>实现思路：将问题的职责解耦和，将Observable和Observer抽象开，分清抽象和实体；</p>
<p><strong><font size="5">void*，NULL和nullptr</font></strong></p>
<p>在C语言中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>
<p>在C++语言中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">define</span> NULL O</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">define</span> NULL （（void *）0）</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在C++11中， <code>nullptr</code>用来替代<code>(void*)0</code>，<code> NULL</code>则只表示<code>0</code>；</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong><font size="5">C 的类型转换</font></strong></p>
<p>С类型转换：</p>
<p>​    隐式类型转换：</p>
<p>​        比如：doublef = 1.0/2；</p>
<p>​    显式类型转换：<br>​        （类型说明）（表达式）</p>
<p>​        比如：double f = double（1）/double（2）；</p>
<p>C类型转换的问题：</p>
<ol>
<li>任意类型之间都可以转换，编译器无法判断其正确性；</li>
<li>难于定位：在源码电无法快速定位；</li>
</ol>
<p><strong><font size="5">C++ 的类型转换</font></strong></p>
<table>
<thead>
<tr>
<th>语句</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>const_cast</td>
<td>用于转换指针或引用，去掉类型的const属性</td>
</tr>
<tr>
<td>reinterpret_cast（很危险）</td>
<td>重新解释类型，既不检查指向的内容，也不检查指针类型本身；但要求转换前后的类型所占用内存大小一致，否则将引发编译时错误。</td>
</tr>
<tr>
<td>static_cast</td>
<td>用于基本类型转换。有继承关系类对象和类指针之间转换，由程序员来确保转换是安全的，它不会产生动态转换的类型安全检查的开销；</td>
</tr>
</tbody></table>
<p><strong><font size="5">适配器（Adapter）模式</font></strong></p>
<ul>
<li>适配器将类接口转换为客户端期望的另一个接口；</li>
<li>使用适配器可防止类由于接口不兼容而一起工作；</li>
<li>适配器模式的动机是，如果可以更改接口，则可以重用现有软件；</li>
</ul>
<p><strong><font size="5">设计模式总结</font></strong></p>
<ul>
<li>23种面向对象设计模式从分类上大致有创建型，结构型和行为型模式；</li>
<li>设计模式不是万能的，它建立在系统变化点上，哪里有变化哪里就可以用；</li>
<li>设计模式为了解耦和，为了扩展，它通常是演变过来的，需要演变才能准确定位；</li>
<li>设计模式是一种软件设计的方法，不是标准，面前大部分的框架中都已经包含了大量设计模式的思想；</li>
</ul>
<h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><p>泛型编程的思想</p>
<ul>
<li>如果说面向对象是一种通过间接层来调用函数，以换取一种抽象，那么泛型编程则是更直接的抽象，它不会因为间接层而损失效率；</li>
<li>不同于面向对象的动态期多态，泛型编程是一种静态期多态，通过编译器生成最直接的代码；</li>
<li>泛型编程可以将算法与特定类型，结构剥离，尽可能复用代码；</li>
</ul>
<p>模板编程的难点很大程度上在于对编译器的理解，我们需要知道怎么帮助编译器提供需要生成代码的信息；</p>
<h1 id="第9章-进阶编程"><a href="#第9章-进阶编程" class="headerlink" title="第9章 进阶编程"></a>第9章 进阶编程</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL（Standard Template Library）</p>
<ul>
<li>STL算法是泛型的（generic），不与任何特定数据结构和对象绑定，不必在环境类似的情况下重写代码；</li>
<li>STL算法可以量身定做，并且具有很高的效率；</li>
<li>STL可以进行扩充，你可以编写自己的组件并且能与STL标准的组件进行很好的配合；</li>
</ul>
<p><strong><font size="5">STL标准库</font></strong></p>
<p><img src="/2021/01/01/C&C++/%E9%87%8D%E5%AD%A6C/image-20201227185649044.png" alt="image-20201227185649044"></p>
<p><strong><font size="5">容器（container）</font></strong><br>容器用于存放数据。STL的容器分为两大类：</p>
<p>序列式容器（Sequence Containers）：</p>
<p>其中的元素都是可排序的（ordered），STL提供了vector， list，deque等序列式容器，而stack， queue， priority-queue则是容器适配器；</p>
<p>关联式容器（Associative Containers）：</p>
<p>每个数据元素都是由一个键（key）和值（Value）组成，当元素被插入到容器时，按其键以某种特定规则放入适当位置；常见的STL关联容器如： set， multiset， map， multimap；</p>
<p><strong><font size="5">仿函数（functor）</font></strong></p>
<ul>
<li>仿函数一般不会单独使用，主要是为了搭配STL算法使用。</li>
<li>函数指针不能满足STL对抽象性的要求，不能满足软件积木的要求无法和STL其他组件搭配；</li>
<li>本质就是类重载了一个operator() ，创建一个行为类似函数的对象；</li>
</ul>
<p><strong><font size="5">算法（algorithm）</font></strong></p>
<p>STL中算法大致分为四类：包含于<code>&lt;algorithm&gt;</code>，<code>&lt;numeric&gt;</code>，<code>&lt;functional&gt;</code></p>
<ol>
<li>非可变序列算法：指不直接修改县所操作的容器内容的算法；</li>
<li>可变序列算法：指可以修改它们所操作的容器内容的算法；</li>
<li>排序算法：包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作；</li>
<li>数值算法：对容器内容进行数值计算；</li>
</ol>
<p>最常见的算法包括：查找，排序和通用算法，排列组合算法，数值算法，集合算法等算；</p>
<p><strong><font size="5">迭代器（iterator）</font></strong></p>
<p>迭代器（iterator）是一种smart pointer，用于访问顺序容器和关联容器中的元素，相当于容器和操纵容器的算法之间的中介；</p>
<p>迭代器按照定义方式分成以下四种：</p>
<ol>
<li>正向迭代器：iterator；</li>
<li>常量正kѣt器：const iterator；</li>
<li>反向选代器：everse iterator；</li>
<li>常量反向迭代器：const reverse iterator</li>
</ol>
<p><strong><font size="5">容器与迭代器（iterator）</font></strong></p>
<table>
<thead>
<tr>
<th>容器</th>
<th>迭代器功能</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>随机访问</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问</td>
</tr>
<tr>
<td>list</td>
<td>双向访问</td>
</tr>
<tr>
<td>set/multiset</td>
<td>双向访问</td>
</tr>
<tr>
<td>map/multimap</td>
<td>双向访问</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>priority_queue</td>
<td>不支持迭代器</td>
</tr>
</tbody></table>
<p><strong><font size="5">容器适配器（adapter）</font></strong></p>
<ul>
<li>stack堆栈：一种”先进后出”的容器，底层数据结构是使用的deque；</li>
<li>queue队列：一种”先进先出”的容器，底层数据结构是使用的deque；</li>
<li>priority_queue优先队列：一种特殊的队列，它能够在队列中进行排序（堆排序），底层实现结构是vector或者deque；</li>
</ul>
<p><strong><font size="5">空间配置器（allocator）</font></strong></p>
<p>《STL源码剖析》侯捷，SGI STL版本的可读性较强；</p>
<p>从使用的角度来看，allocator隐藏在其他组件中默默工作，不需要关心，但是从理解STL实现角度来看，它是需要首先分析的组件；</p>
<p>allocator的分析可以体现C++在性能和资源管理上优化思想；</p>
<p><strong><font size="5">STL总结</font></strong></p>
<p>STL的六大组件给软件编程带来了新的多态和复用，是现代C++语言高效的精髓；</p>
<p>泛型和STL的学习路线很陡，建议初学者先学会基本使用和简单扩展；</p>
<p>掌握了一定基础的情况下，可以通过进一步学习和分析源码，编写自己的组佣来提升能力；</p>
<p><strong><font size="5">关于Boost库</font></strong></p>
<p>Boost库是为C++语言标准库提供扩展的一些C++程序库的总称，由Boost社区组织开发、维护，Boost库可以与C++标准库完美共同工作，并且为其提供扩展功能；</p>
<p>Boost可为大致为20多个分类：</p>
<p>字符串和文本处理库，容器库，算法库，函数对象和高阶编程库，综合类库等等；</p>
<p>具体见：<a target="_blank" rel="noopener" href="https://www.boost.org/">https://www.boost.org/</a><br><a target="_blank" rel="noopener" href="https://dl.bintray.com/boostorg/release/">https://dl.bintray.com/boostorg/release/</a></p>
<p><strong><font size="5">C++多线程</font></strong></p>
<ul>
<li>C++11 中Thread的使用；</li>
<li>mutex等锁的使用；</li>
<li>进程与线程，同步与异步；</li>
<li>线程的交换与移动；</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="prev" title="算法笔记">
      <i class="fa fa-chevron-left"></i> 算法笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/01/JAVA/jdk%E7%9B%B8%E5%85%B3/" rel="next" title="jdk相关">
      jdk相关 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC1%E7%AB%A0-%E6%A6%82%E6%8B%AC"><span class="nav-number">1.</span> <span class="nav-text">第1章 概括</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C%EF%BC%8CC-%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="nav-number">1.1.</span> <span class="nav-text">C，C++发展历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88C-%E6%AF%94C%E6%9B%B4%E5%A5%BD"><span class="nav-number">1.2.</span> <span class="nav-text">为什么C++比C更好</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.</span> <span class="nav-text">C++的特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">第2章 基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">2.2.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="nav-number">2.3.</span> <span class="nav-text">变量和常量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">第3章 运算符与表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.1.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">3.2.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81"><span class="nav-number">3.3.</span> <span class="nav-text">补码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">第4章 基础容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">4.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector"><span class="nav-number">4.2.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.3.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string"><span class="nav-number">4.4.</span> <span class="nav-text">string</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%8C%87%E9%92%88%EF%BC%8C%E5%BC%95%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">第5章 指针，引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.</span> <span class="nav-text">指针的定义和间接访问操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC"><span class="nav-number">5.2.</span> <span class="nav-text">左值与右值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88"><span class="nav-number">5.3.</span> <span class="nav-text">原始指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F"><span class="nav-number">5.4.</span> <span class="nav-text">存储区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RAII%E5%88%9D%E6%AD%A5"><span class="nav-number">5.5.</span> <span class="nav-text">RAII初步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">5.6.</span> <span class="nav-text">安全的指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">5.7.</span> <span class="nav-text">引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%9F%BA%E7%A1%80%E5%8F%A5%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">第6章 基础句法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.1.</span> <span class="nav-text">分支语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.</span> <span class="nav-text">自定义结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E7%9C%81%E5%AF%B9%E9%BD%90%E5%8E%9F%E5%88%99"><span class="nav-number">6.3.</span> <span class="nav-text">缺省对齐原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.4.</span> <span class="nav-text">循环语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">6.5.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">6.6.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95"><span class="nav-number">6.7.</span> <span class="nav-text">递归与数学归纳法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E9%AB%98%E7%BA%A7%E5%8F%A5%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">第7章 高级句法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.1.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O%E6%B5%81"><span class="nav-number">7.2.</span> <span class="nav-text">I&#x2F;O流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">7.3.</span> <span class="nav-text">面向对象三大特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="nav-number">8.</span> <span class="nav-text">第8章 编程思想</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.1.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">8.2.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">8.3.</span> <span class="nav-text">泛型编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC9%E7%AB%A0-%E8%BF%9B%E9%98%B6%E7%BC%96%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">第9章 进阶编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STL"><span class="nav-number">9.1.</span> <span class="nav-text">STL</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lemonforce</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lemonforce</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script color='' opacity='' zIndex='' count='' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'gzXD9zEDA40Tphr5SR3SdW1Q-gzGzoHsz',
      appKey     : 'OhkBCtuVUlWsxS1Bm4jQVLgX',
      placeholder: "有啥想说的，尽情留言",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
